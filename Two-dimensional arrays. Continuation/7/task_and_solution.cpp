/*
Вывести маршрут максимальной стоимости
В левом верхнем углу прямоугольной таблицы размером N×M находится черепашка. В каждой клетке таблицы записано некоторое число. Черепашка может перемещаться вправо или вниз, при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.

Подсчитаем сумму чисел, записанных в клетках, через которую проползла черепашка (включая начальную и конечную клетку). Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.

Входные данные
В первой строке входных данных записаны два натуральных числа N и M, не превосходящие 100 — размеры таблицы. Далее идут N строк, каждая из которых содержит M чисел, разделённых пробелами — описание таблицы. Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.

Выходные данные
Первая строка выходных данных содержит максимальную возможную сумму, вторая — маршрут, на котором достигается эта сумма. Маршрут выводится в виде последовательности, которая должна содержать N−1 букву D, означающую передвижение вниз, и M−1 букву R, означающую передвижение вправо. Если таких последовательностей несколько, необходимо вывести ровно одну (любую) из них.

Примеры
Ввод
5 5
9 9 9 9 9
3 0 0 0 0
9 9 9 9 9
6 6 6 6 8
9 9 9 9 9

Вывод
74
D D R R R R D D 

*/

#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    n++;
    m++;
    vector <vector <int>> field (n, vector <int>(m, 0));
    vector <vector <int>> dp (n, vector <int>(m, 0));
    for (int i = 1; i < n; ++i) {
        for (int j = 1; j < m; ++j) {
            cin >> field[i][j];
        }
    }
    
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + field[i][j]; // + field[i][j];
        }
    }


    cout << dp[n - 1][m - 1] << endl;

    vector <int> answer;
    int now_n = n - 1;
    int now_m = m - 1;
    while (now_n > 0 && now_m > 0) {
        if (dp[now_n][now_m] == dp[now_n - 1][now_m] + field[now_n][now_m]) {
            answer.push_back(1);
            now_n--;
        } else {
            answer.push_back(2);
            now_m--;
        }
    }

    for (int i = answer.size() - 2; i >= 0; i--) {
        if (answer[i] == 1) {
            cout << "D" << " ";
        } else {
            cout << "R" << " ";
        }
    }

}
